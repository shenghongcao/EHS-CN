**从计算机术语来讲**（In computer terms），Smalltalk在计算机中是一种[递归](http://baike.baidu.com/view/96473.htm)的**观念**（notion）。
**而不是把“计算机”分开一个个单独的个体**（Instead of dividing "computer stuff" into things each less strong than the whole）——
如数据结构，程序，**函数**（functions）这些编程语言必备的元素——
**Smalltalk的每个对象都是以递归的方式发生在计算机中**（each Smalltalk object is a recursion on the entire possibilities of the computer.）。
因此，通过一个非常快的网络，**它的呈现的效果**（its semantics）有点像有成千上万的计算机都连接在一起。
**具体表现的问题因此可以几乎无限地被推迟,因为我们主要是关心电脑适当的行为,和感兴趣的特定策略只有结果已经关闭或者返回的太慢。**（Questions of concrete representation can thus be postponed almost indefinitely because we are mainly concerned that the computers behave appropriately, and are interested in particular strategies only if the results are off or come back too slowly.）

在计算机术语中，Smalltalk是基于计算机本身概念的一种[递归（recursion）](http://baike.baidu.com/view/96473.htm)。它并没有把“计算机中的事物”分割成一个个弱化了的部分——如数据结构（ data structures）、流程（procedures）和函数（functions），它们都是编程语言中不可或缺的部分——在计算机整个运行过程中，每个Smalltalk的对象都是递归的。因此，语义上来看，这就像一个非常迅速的网络连接着成千上万的计算机。由于我们主要关心的是电脑行为是否恰当，或者如何具体解决结果意外关闭或返回的太慢的问题，因此，在解决具体呈现的问题方面，我们会无限期地拖延。
